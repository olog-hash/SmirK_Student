# Информация о программе

Программа написана на .NET 6 и C# 10.
Framework для разработки выбран как ASP.NET Core Web API.
IDE: JetBrains Rider 2025.2

## Информация о задании (для практикантов и стажеров)

Реализовать механизм подбора водителя на заказ.

Карта представляет из себя прямоугольную сетку размером N x M, которая состоит из квадратов размером 1х1, в каждом из которых может находиться только один водитель.
Координаты расположения водителя или заказа представлены в виде простых чисел X и Y, где 0 <= X < N, 0 <= Y < M. 
Каждый водитель имеет уникальный идентификатор, который указывается при добавлении или изменении его координат.

В первой части необходимо реализовать три и более разных алгоритмов, которые будут искать пять ближайших к заказу водителей.
Производительность алгоритмов нужно сравнить, используя библиотеку [Benchmark](https://github.com/dotnet/BenchmarkDotNet).  
Скриншот(-ы) результатов сравнения нужно добавить в Readme.md файл в Git.
Все разработанные алгоритмы вы должны покрыть тестами, используя NUnit.

## Ветка выполнения задания

Задание выполнялось изначально в ветке [fist-task](https://github.com/olog-hash/SmirK_Student/commit/03f604092ce17ff73ff288b0008b43fb1aaeeae6)

---

# Отчет о выполненном задании

## Архитектурное решение
Для решения задачи был выбран подход разделения способы хранения данных и алгоритма поиска.
Реализовано три типа контейнеров для хранения водителей, каждый из которых оптимизирован под определенные сценарии использования.
Для каждого контейнера разработаны специализированные алгоритмы поиска, эффективно использующие структуру данных.

Все алгоритмы поиска реализуют паттерн "стратегия", через базовый абстрактный класс BaseDriverSearchStrategy<TContainer>, что позволяет легко добавлять новые алгоритмы и переключаться между ними. (Он так же инкапсулирует логику проверки вводных данных на наличие ошибок и возвращает пустой список. Можно переопределить для каждого алгоритма опционально при желании).

## Реализованные контейнеры и алгоритмы

**1. ListGrid - Словарь водителей**

**Описание:** Простейший контейнер, хранящий водителей в виде словаря `Dictionary<int, DriverOnMap>`, где ключ - уникальный ID водителя. Доступ к водителю выполняется за О(1), однако поиск по координатам требует полного перебора всех участников списка.

**Структура данных:**
- Словарь для хранения водителей по ID.
- Поиск по координатам путем перебора водителей.

**Алгоритмы:**

- **BruteForceAlgorithm (Линейный перебор)** - перебирает всех доступных водителей из списка, вычисляет Манхэттенское расстояние до каждого и с помощью приоритетной очереди отбирает N ближайших. Оптимален для любых карт, и малого количества водителей.

**2. ClassicGrid - Двумерная сетка 1:1**

**Описание:** Контейнер представляет собой двумерную сетку, где каждая клетка соответствует одной единице координат на карте. Под капотом используется одномерный массив, обернутый в класс `FastGrid<T>` (фасад) для повышения производительности, благодаря последовательному расположению данных в памяти.

**Структура данных:**
- Одномерный массив для хранения содержимого клеток по координатам
- Словарь для быстрого доступа к водителю по ID

**Алгоритмы:**

- **BFSAlgorithm (Поиск в ширину)** - классический алгоритм обхода графа в ширину (BFS). Начиная от точки заказа, волнообразно расширяется по соседним клеткам (↑ ↓ ← →), используя очередь и массив посещенных клеток. Оптимален, для небольших карт, когда водители находятся близко к точке заказа.
- **ManhattanRadialSearch (Ромбовидный послойный поиск)** - обходит клетки ромбовидными слоями на основе Манхэттенского расстояния (все клетки на расстояния от точки на 1, затем 2, 3, и т.д.). Ключевая оптимизация - вместо проверки всех клеток слоя, вычисляются граничные точки (вершины ромба), по которым строятся диагонали с автоматическим обрезанием за границами карты. Оптимален для карт среднего размера с средним распределением водителей.

**3. SpatialGrid - Секторальная сетка**

**Описание:** Улучшенная версия двумерной сетки, разбивающая карту на секторы (ячейки) фиксированного размера (например 10х10 клеток). Водители группируются по секторам и хранятся в словаре `Dictionary<GridCell, List<DriverOnMap>>`. Это позволяет проверять не отдельные клетки, а целые секторы, значительно сокращая количество проверок.

**Структура данных:**
- Словарь сектором со списками водителей в каждом
- Словарь для быстрого доступа к водителю по ID
- Ленивая инициализация списков для секторов (и чистка при опустошении ячейки после удаления водителя)

**Алгоритмы:**

- **SectorGridAlgorithm (Послойный поиск по секторам)** - выполняет обход секторов квадратными слоями от точки заказа. Проверяет всех водителей текущего слоя. Ключевая оптимизация: досрочное прерывание поиска. Если минимально возможное расстояние до следующего слоя больше, чем расстояние до самого дальнего из уже найденных водителей, поиск останавливается - в следующих слоях гарантированно не будет более близких водителей. Оптимален для больших карт с неравномерным распределением водителей и при использовании подходящего размера сектора.

## Результаты бенчмарков

**Конфигурация тестирования**
- **Процессор**: Intel Core i5-12400F @ 2.50GHz (6 cores, 12 threads)
- **ОС**: Windows 10 (22H2)
- **.NET**: 6.0.36

**План бенчмарков проводился по следующим параметрам, для всех алгоритмов:**
- Размер карты: 100х100, 500х500, 1000х1000
- Плотность водителей: 1%, 10%
- Размещение водителей: Random (случайное), WorstCase (худший случай)
- Максимальное количество ближайших водителей: 10, 100
- Позиция заказа: Center (центр карты), Corner (угол карты)

Seed для генерации случайных позиций = 17. Размер ячеек (cellgrid) для SpartialGrid вычислялся по формуле `Math.Max(1, (int)(Math.Sqrt(MapSize) / 4));`

**Таблицы с результатами была оформлена в удобном порядке по параметрам:**
<details>
  
### Карта 100x100

|Алгоритм|Плотность|Размещение|MaxDrivers|Позиция|Время (ns)|Память (B)|
|---|---|---|---|---|---|---|
|**BruteForce**|0.01|Random|10|Center|4,007|1,048|
|BruteForce|0.01|Random|10|Corner|3,960|1,048|
|BruteForce|0.01|Random|100|Center|5,465|7,936|
|BruteForce|0.01|WorstCase|10|Center|3,597|1,048|
|BruteForce|0.01|WorstCase|100|Corner|5,169|7,936|
|BruteForce|0.10|Random|10|Center|40,406|1,048|
|BruteForce|0.10|Random|100|Center|88,553|7,936|
|BruteForce|0.10|WorstCase|10|Center|32,651|1,048|
|BruteForce|0.10|WorstCase|100|Corner|71,614|7,936|
|**BFS**|0.01|Random|10|Center|18,898|15,144|
|BFS|0.01|Random|10|Corner|22,314|13,072|
|BFS|0.01|Random|100|Center|147,252|25,800|
|BFS|0.01|WorstCase|10|Center|142,805|19,264|
|BFS|0.01|WorstCase|100|Corner|146,620|21,680|
|BFS|0.10|Random|10|Center|3,192|13,072|
|BFS|0.10|Random|100|Center|19,359|21,680|
|BFS|0.10|WorstCase|10|Center|52,583|19,264|
|BFS|0.10|WorstCase|100|Corner|130,973|21,680|
|**DistanceSearch**|0.01|Random|10|Center|2,616|872|
|DistanceSearch|0.01|Random|10|Corner|3,857|872|
|DistanceSearch|0.01|Random|100|Center|21,273|7,408|
|DistanceSearch|0.01|WorstCase|10|Center|18,979|872|
|DistanceSearch|0.01|WorstCase|100|Corner|24,334|7,408|
|DistanceSearch|0.10|Random|10|Center|540|1,032|
|DistanceSearch|0.10|Random|100|Center|3,065|7,408|
|DistanceSearch|0.10|WorstCase|10|Center|7,252|872|
|DistanceSearch|0.10|WorstCase|100|Corner|21,720|7,824|
|**SectorGrid**|0.01|Random|10|Center|14,949|16,160|
|SectorGrid|0.01|Random|10|Corner|30,257|71,832|
|SectorGrid|0.01|Random|100|Center|67,555|70,192|
|SectorGrid|0.01|WorstCase|10|Center|70,331|63,304|
|SectorGrid|0.01|WorstCase|100|Corner|105,747|242,568|
|SectorGrid|0.10|Random|10|Center|4,838|3,960|
|SectorGrid|0.10|Random|100|Center|28,614|23,048|
|SectorGrid|0.10|WorstCase|10|Center|63,273|46,248|
|SectorGrid|0.10|WorstCase|100|Corner|151,478|242,568|

### Карта 500x500

|Алгоритм|Плотность|Размещение|MaxDrivers|Позиция|Время (ns)|Память (B)|
|---|---|---|---|---|---|---|
|**BruteForce**|0.01|Random|10|Center|110,096|1,048|
|BruteForce|0.01|Random|10|Corner|90,979|1,048|
|BruteForce|0.01|Random|100|Center|202,662|7,936|
|BruteForce|0.01|WorstCase|10|Center|79,778|1,048|
|BruteForce|0.01|WorstCase|100|Corner|179,091|7,936|
|BruteForce|0.10|Random|10|Center|1,108,865|1,048|
|BruteForce|0.10|Random|100|Center|1,885,718|7,936|
|BruteForce|0.10|WorstCase|10|Center|791,397|1,048|
|BruteForce|0.10|WorstCase|100|Corner|1,573,458|7,936|
|**BFS**|0.01|Random|10|Center|33,362|255,230|
|BFS|0.01|Random|10|Corner|40,126|253,189|
|BFS|0.01|Random|100|Center|201,307|274,212|
|BFS|0.01|WorstCase|10|Center|3,426,454|284,410|
|BFS|0.01|WorstCase|100|Corner|3,804,142|274,514|
|BFS|0.10|Random|10|Center|26,990|253,074|
|BFS|0.10|Random|100|Center|49,727|261,684|
|BFS|0.10|WorstCase|10|Center|1,088,048|284,185|
|BFS|0.10|WorstCase|100|Corner|3,094,556|274,342|
|**DistanceSearch**|0.01|Random|10|Center|2,095|872|
|DistanceSearch|0.01|Random|10|Corner|3,712|872|
|DistanceSearch|0.01|Random|100|Center|25,249|7,408|
|DistanceSearch|0.01|WorstCase|10|Center|474,146|872|
|DistanceSearch|0.01|WorstCase|100|Corner|599,942|7,568|
|DistanceSearch|0.10|Random|10|Center|502|1,032|
|DistanceSearch|0.10|Random|100|Center|2,996|7,408|
|DistanceSearch|0.10|WorstCase|10|Center|130,638|872|
|DistanceSearch|0.10|WorstCase|100|Corner|503,277|7,600|
|**SectorGrid**|0.01|Random|10|Center|3,932|3,960|
|SectorGrid|0.01|Random|10|Corner|7,373|13,968|
|SectorGrid|0.01|Random|100|Center|43,895|31,816|
|SectorGrid|0.01|WorstCase|10|Center|332,347|244,064|
|SectorGrid|0.01|WorstCase|100|Corner|532,250|949,328|
|SectorGrid|0.10|Random|10|Center|3,189|1,600|
|SectorGrid|0.10|Random|100|Center|20,778|10,848|
|SectorGrid|0.10|WorstCase|10|Center|460,236|143,456|
|SectorGrid|0.10|WorstCase|100|Corner|1,882,291|949,328|

### Карта 1000x1000

|Алгоритм|Плотность|Размещение|MaxDrivers|Позиция|Время (ns)|Память (B)|
|---|---|---|---|---|---|---|
|**BruteForce**|0.01|Random|10|Center|444,628|1,048|
|BruteForce|0.01|Random|10|Corner|358,988|1,048|
|BruteForce|0.01|Random|100|Center|771,784|7,936|
|BruteForce|0.01|WorstCase|10|Center|313,977|1,048|
|BruteForce|0.01|WorstCase|100|Corner|656,456|7,936|
|BruteForce|0.10|Random|10|Center|4,791,151|1,048|
|BruteForce|0.10|Random|100|Center|7,314,061|7,936|
|BruteForce|0.10|WorstCase|10|Center|3,293,485|1,048|
|BruteForce|0.10|WorstCase|100|Corner|5,701,761|7,936|
|**BFS**|0.01|Random|10|Center|77,020|1,005,172|
|BFS|0.01|Random|10|Corner|83,532|1,003,121|
|BFS|0.01|Random|100|Center|274,577|1,024,068|
|BFS|0.01|WorstCase|10|Center|18,432,111|1,066,680|
|BFS|0.01|WorstCase|100|Corner|22,462,497|1,040,424|
|BFS|0.10|Random|10|Center|140,050|1,002,052|
|BFS|0.10|Random|100|Center|156,215|1,011,693|
|BFS|0.10|WorstCase|10|Center|5,137,099|1,066,796|
|BFS|0.10|WorstCase|100|Corner|18,787,403|1,040,424|
|**DistanceSearch**|0.01|Random|10|Center|1,187|872|
|DistanceSearch|0.01|Random|10|Corner|2,651|872|
|DistanceSearch|0.01|Random|100|Center|22,456|7,408|
|DistanceSearch|0.01|WorstCase|10|Center|3,006,623|872|
|DistanceSearch|0.01|WorstCase|100|Corner|5,436,030|7,568|
|DistanceSearch|0.10|Random|10|Center|414|936|
|DistanceSearch|0.10|Random|100|Center|3,021|7,600|
|DistanceSearch|0.10|WorstCase|10|Center|590,481|872|
|DistanceSearch|0.10|WorstCase|100|Corner|6,417,387|7,600|
|**SectorGrid**|0.01|Random|10|Center|1,486|1,600|
|SectorGrid|0.01|Random|10|Corner|2,941|5,104|
|SectorGrid|0.01|Random|100|Center|25,527|18,664|
|SectorGrid|0.01|WorstCase|10|Center|836,066|477,640|
|SectorGrid|0.01|WorstCase|100|Corner|1,420,428|1,892,840|
|SectorGrid|0.10|Random|10|Center|1,661|1,272|
|SectorGrid|0.10|Random|100|Center|14,488|9,096|
|SectorGrid|0.10|WorstCase|10|Center|1,555,188|269,216|
|SectorGrid|0.10|WorstCase|100|Corner|7,523,910|1,892,840|

</details>

**Скриншоты из бенчмарка из консоли программы:**

<details>
  
  ![Part_1](https://github.com/user-attachments/assets/ae98cd4e-bffe-43fd-9ace-909ba49d8724)
  
  ![Part_2](https://github.com/user-attachments/assets/6d8113d0-4faa-4d91-af2d-bc23e8b4af18)
  
  ![Part_3](https://github.com/user-attachments/assets/0929aea1-915d-4ef8-afcb-84ca72211265)
  
  ![Part_4](https://github.com/user-attachments/assets/d6658836-b930-4249-906d-0b02cf131273)
  
  ![Part_5](https://github.com/user-attachments/assets/77245d97-6d3f-41f7-bbfb-3ec5d0e57950)
  
</details>

### Анализ результатов

#### Малая карты (100х100)

При низкой плотности водителей (1%) все алгоритмы показывают достаточно приемлемую производительность. DistanceSearch демонстрирует лучшее время (2.65 μs) благодаря эффективному ромбовидному обходу. При высокой плотности (10%) DistanceSearch остается лидером (0.54 μs), так как быстро находит водителей в ближайших слоях.

BFS показывает нестабильную производительность: на низкой плотности работает медленно (18.9 μs), но на высокой плотности превосходит BruteForce (3.19 μs против 40.41 μs), так как водители находятся ближе к точке заказа.

SectorGrid на малых картах неэффективен из-за накладной работы с секторами при малом количестве данных - сначала ему требуется найти нужный сектор в словаре, а потом перебирать в нем водителей.

#### Средняя карта (500х500)

На средних картах уже четче проявляются различия между алгоритмами. DistanceSearch сохраняет лидерство при любой конфигурации: от 0.5 μs (на высокой плотности) до 474.15 μs (при худшем сценарии на низкой плотности).

BruteForce начинает значительно деградировать при росте количества водителей: при плотности 10% время достигает 1,108.87 μs, что в 2,216 раз медленнее DistanceSearch.

SectorGrid на средних картах начинает проявлять свои преимущества при высокой плотности (3.19 μs для 10% плотности), но с худших сценариях уступает DistanceSearch

BFS показывает себя хуже всех алгоритмов в этом случаи. При сложных сценариях (удаленность водителей к краям карты, большая численность требуемых водителей), алгоритм показывает от 1,088 μs до 3,804 μs.

#### Большая карта (1000х1000)

На больших картах DistanceSearch и SectorGrid демонстрируют наилучшие результаты. При случайном распределении и высокой плотности SectorGrid показывает время 1.66 μs против 0.41 μs у DistanceSearch - разница минимальна.

BruteForce полностью непригоден для больших карт: при плотности 10% время достигает 4.79 ms, что в 11,680 раз медленнее DistanceSearch.

BFS на больших картах тоже испытывает трудности: от 18.432 ms до 22.462 мс. Отдельно можно отметить его значительное потребление памяти ~ 1 MB, из-за необходимости хранения массива посещенных клеток. Все это делает данный алгоритм неоптимальным в качестве выбора.

## Покрытие тестами

Все алгоритмы и контейнеры покрыты юнит-тестами с использованием фреймворка NUnit. Благодаря использованию паттернов и абстрактных базовых классов, выстроенная система позволяет достаточно гибко создать единую базу тестов, которая автоматический применяется ко всем реализациям контейнеров и алгоритмов. Тем более это правильно, ибо задача должна выполняться как правило одинаково для всех разработанных алгоритмов.

Тестирование было разделено на три основные категории, каждая из которых проверяет свою зону функциональности.

### 1. Тестирование работы контейнеров (BaseContainerTests)
Данная категория проверяет корректность работы контейнеров для хранения водителей. Тесты проверяют основные операции работы с данными независимо от алгоритмов поиска.

**1.1 Валидация границ карты:**
- Добавление водителя с отрицательной координатой по X или Y возвращает InvalidPosition
- Добавление водителя за пределами ширины или высоты карты возвращает InvalidPosition
- Перемещение существующего водителя на отрицательные координаты возвращает InvalidPosition
- Перемещение существующего водителя за границы карты возвращает InvalidPosition

**1.2 Обработка конфликтов позиций:**
- Добавление нового водителя на позицию, занятую другим водителем, возвращает OccupiedPosition
- Перемещение водителя на позицию, занятую другим водителем, возвращает OccupiedPosition
- Перемещение водителя на его собственные координаты возвращает Updated

**1.3 Корректность операций добавления:**
- Добавление водителя на свободную валидную позицию возвращает Added
- Последовательное добавление нескольких водителей на разные позиции успешно выполняется
- Перемещение существующего водителя на новую свободную позицию возвращает Updated

**1.4 Корректность операций удаления:**
- Удаление существующего водителя возвращает Removed и уменьшает счетчик
- Удаление несуществующего водителя возвращает InvalidDriver
- Удаление водителя после неудачного добавления возвращает InvalidDriver
- Последовательное удаление нескольких водителей корректно обрабатывается

**1.5 Целостность счетчика водителей:**
- Счетчик увеличивается при добавлении водителей
- Счетчик уменьшается при удалении водителей
- Счетчик не изменяется при неудачных операциях

**1.6 Стресс-тестирование массовыми операциями:**
- Последовательное добавление 100 водителей на уникальные позиции
- Последовательное удаление всех 100 водителей
- Выполнение 100 операций перемещения водителей (10 водителей x 10 перемещений)

**1.7 Повторное использование идентификаторов:**
- ID удаленного водителя можно использовать для создания нового водителя
- Позиция удаленного водителя может быть занята новым водителем
- Новый водитель с повторно использованным ID является независимым объектом

**1.8 Освобождение позиций при перемещении:**
- При перемещении водителя его старая позиция освобождается
- При перемещении нескольких водителей все старые позиции освобождаются корректно

### 2. Тестирование работоспособности алгоритмов (BaseAlgorithmTests)
Данная категория проверяет корректность работы алгоритмов поиска при различных входных данных в конфигурациях карты.

**2.1 Обработка некорректных параметров поиска:**
- Поиск с отрицательной координатой X или Y возвращает пустой список
- Поиск с координатой X или Y за пределами карты возвращает пустой список
- Поиск с maxDrivers <= 0 возвращает пустой список

**2.2 Работа на минимальной сетке 1х1:**
- Поиск на пустой сетке 1×1 возвращает пустой список
- Поиск единственного водителя на сетке 1х1 возвращает водителя с расстоянием 0
- После удаления водителя поиск возвращает пустой список

**2.3 Работа на обычной квадратной сетке 9х9:**
- Поиск на пустой сетве 9х9 возвращает пустой список
- Поиск единственного водителя корректно вычисляет расстояние
- Размещение водителей по четырем углам и поиск из центра находит всех с одинаковым расстоянием
- После удаления водителя он не появляется в результатах поиска
- Перемещение водителя на его текущие координаты не вызывает ошибок
- Попытка переместить водителя за границу отклоняется, водитель остается на старой позиции
- Попытка переместить водителя на занятую позицию отклоняется

**2.4 Работа на узкой прямоугольной сетке 1х9:**
- Поиск на пустой сетке 1x9 возвращает пустой список
- Единственный водитель на линии находится с правильным расстоянием
- Несколько водителей на линии находятся в правильном порядке по возрастанию расстояния

**2.5 Работа на прямоуголько сетке 3х9:**
- Поиск на пустой сетке 3x9 возвращает пустой список
- Единственный водитель находится с корректным расстоянием

**2.6 Функциональные тесты в нормальных условиях:**
- При maxDrivers = 1 алгоритм возвращает одного ближайшего водителя
- При maxDrivers равном количеству водителей возвращаются все водители
- При maxDrivers больше количества водителей возвращаются все доступные
- Результаты отсортированы по возрастанию расстояния
- Расстояния вычисляются корректно для известных конфигураций

### 3. Тестирование мат-части (BaseMathematicalCorrectnessTests)
Данная категория проверяет математическую точность алгоритмов и их способность действительно находить ближайших водителей согласно метрике манхэттенского расстояния.

**3.1 Точность вычисления расстояний:**
- Водитель в точке заказа имеет расстояние 0
- Для известных конфигураций точек вычисляются ожидаемые манхэттенские расстояния
- Все вычисленные расстояния неотрицательные

**3.2 Свойство ближайших водителей:**
- Если найден водитель на расстоянии D, все водители на расстояниях 0...D-1 также найдены
- Водители на слоях расстояний находятся строго по слоям в порядке возрастания

**3.3 Математические варианты результата:**
- Результаты строго отсортированы по неубыванию расстояния
- Количество результатов не превышает maxDrivers
- Количество результатов не превышает реально доступных водителей

**3.4 Поиск из граничных позиций:**
- Поиск из левого верхнего угла находит ближайших водителей корректно
- Поиск из правого нижнего угла находит ближайших водителей корректно
- Поиск из центра карты находит симметрично расположенных водителей с одинаковым расстоянием

**3.5 Специальные настройки водителей:**
- Все водители на одинаковом расстоянии от точки поиска находятся все
- Водители по прямой линии (лестница) находятся строго в порядке возрастания
- Горизонтальная линия водителей обрабатывается с учетом симметрии
- Вертикальная линия водителей обрабатывается с учетом симметрии

**3.6 Прочие сценарии:**
- Одинокий близкий водитель находится первым при наличии плотного скопления далеких
- При широком разбросе расстояний находятся только N ближайших, остальные отсекаются
