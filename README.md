# Информация о программе

Программа написана на .NET 6 и C# 10.
Framework для разработки выбран как ASP.NET Core Web API.
IDE: JetBrains Rider 2025.2

## Информация о задании: Часть II (для стажеров)

Задачи второй части:
- Перенести лучший по производительности алгоритм из первой части в ASP.NET Core Web API приложение
- Реализовать эндпоинт добавления/изменения координат водителя с проверками и соответствующими ответами
- Реализовать эндпоинт подбора водителя на заказ с использованием удалённого API для рандомизации
- Размеры карты и параметры сервиса вынести в appsettings.json
- Добавить поддержку Swagger UI для удобной отправки запросов
- Реализовать собственный механизм ограничения параллельных запросов с возвратом HTTP 503 при превышении лимита

### Введение и выбор алгоритма
По результатам бенчмарков из первой части был выбран алгоритм DistanceSearchAlgorithm (ромбовидный послойный поиск) в связке с контейнером ClassicGrid (двумерная сетка 1:1). Эта комбинация показала наилучшую производительность в большинстве сценариев: от 0.41 μs при высокой плотности водителей до стабильных результатов на картах до 1000×1000, при этом потребление памяти не превышало ~8 KB. Алгоритм уступал конкурентам лишь в узких случаях (WorstCase при очень большом количестве искомых водителей), которые не очень актуальны для реальных условий использования.

Приложение построено на базе ASP.NET Core Web API (.NET 6, C# 10), среда разработки - JetBrains Rider 2025.

### Добавленные сервисы

**1. DriverLocationAdapter**

Для связки алгоритма поиска и контейнера с водителями с новой бизнес-логикой второй части (эндпоинты, валидация по ТЗ, построение маршрута, рандомизация) был разработан сервис-адаптер DriverLocationAdapter<TContainer, TAlgorithm>. Его назначение - надстройка над алгоритмом и контейнером, которая добавляет необходимую логику обработки запросов, не изменяя при этом сам контейнер и алгоритм (принцип открытости/закрытости).

Благодаря тому, что адаптер является использует generic, при желании можно заменить контейнер и алгоритм на любую другую совместимую пару - достаточно изменить одну строку при регистрации, и всё подключится и будет работать штатно. Если же контейнер и алгоритм окажутся несовместимы (например, BFSAlgorithm требует ClassicGrid, а передан ListGrid), это обнаружиться ещё на этапе компиляции из-за ограничений generic-типов.

**2. RandomizeService**

Сервис генерации случайных чисел, который в первую очередь обращается к удалённому API randomnumberapi.com для получения случайного числа в заданном диапазоне. Если же внешний API окажется недоступен или вернет ошибку (сетевые проблемы, HTTP-ошибки), сервис автоматически переключается на встроенные средства генерации C# (System.Random), тем самым обеспечивая штатную работу приложения.


### Выполнение пунктов задания

**1. Конфигурация размеров карты**

Размеры карты NхM задаются в файле appsettings.json в секции MapSettings с параметрами Width и Height. При запуске приложения значения привязываются к модели MapSettingsConfig через механизм IOptions<T> и регистрируются в DI-контейнере. Далее при создании Singleton'а DriverLocationAdapter значения извлекаются из конфига и передаются в конструктор ClassicGrid, создавая сетку нужного размера.

**2. Эндпоинт добавления/изменения координат водителя**

Реализован эндпоинт POST /DriverOrder/AddOrUpdateDriver, принимающий в теле запроса JSON-объект со следующей структурой: DriverID (идентификатор водителя), X (координата по горизонтали), Y (координата по вертикали).

При поступлении запроса контроллер делегирует обработку адаптеру DriverLocationAdapter, который вызывает метод AddOrUpdateDriver контейнера ClassicGrid. Контейнер последовательно выполняет проверки: валидность координат (0 <= X < N, 0 <= Y < M), незанятость нужной позиции, наличие водителя с указанным ID на карте. В зависимости от результата проверок контроллер формирует соответствующий ответ:

- Координаты выходят за пределы карты → HTTP 400 с сообщением "Координаты некорректны".
- Позиция занята другим водителем → HTTP 400 с сообщением "Здесь уже находится другой водитель". Текущие координаты водителя при этом не изменяются.
- Водитель успешно добавлен на карту впервые → HTTP 200 с сообщением "Координаты успешно добавлены".
- Существующий водитель перемещён на новую позицию (или остался на прежней) → HTTP 200 с сообщением "Координаты успешно изменены".

Отдельно стоит пояснить момент при указании координат за пределами карты для существующего водителя. В ТЗ сказано: "его предыдущие координаты должны быть удалены", однако не уточняется, подразумевается ли полное удаление водителя с карты или лишь маркировка о недоступности. По итогу принято решение об удалении: если водитель уже находился на карте, но присылает координаты за её пределами, адаптер после получения результата InvalidPosition дополнительно вызывает RemoveDriver, стирая предыдущую позицию. Если в дальнейшем потребуется вернуть водителя с тем же ID на карту - он просто создастся заново при следующем корректном запросе.

**3. Эндпоинт подбора водителя на заказ**

Реализован эндпоинт POST /DriverOrder/FindDriverForOrder, принимающий в теле запроса JSON-объект со следующей структурой: OrderID (идентификатор заказа), X (координата заказа по горизонтали), Y (координата заказа по вертикали).

Обработка запроса проходит через несколько этапов. Сначала адаптер проверяет координаты заказа и наличие водителей на карте. Затем алгоритм ManhattanRadialSearch выполняет поиск до 5 ближайших водителей (значение по умолчанию), обходя клетки ромбовидными слоями от точки заказа.

Из списка найденных водителей один выбирается случайным образом через класс RandomizeService. Сервис запрашивает случайное число из диапазона [0, количество найденных водителей) у внешнего API randomnumberapi.com. Полученное число используется как индекс в списке водителей. Если внешний API недоступен - индекс генерируется стандартными средствами C#.

После выбора водителя строится маршрут от его позиции до точки заказа. Построение маршрута делегирован классу-утилите RouteMathUtilits.BuildRoute. Маршрут строится по Манхэттенскому принципу: сначала движение по оси X до совпадения координаты, затем по оси Y. Размер массива координат маршрута рассчитывается заранее на основе Манхэттенского расстояния, что позволяет избежать лишних аллокаций и расширений при заполнении массива (или списка).

При успешном подборе возвращается HTTP 200 с JSON-объектом, содержащим: DriverID (идентификатор выбранного водителя), DriverPosition (координаты водителя), Distance (длина маршрута), RouteArray (массив координат маршрута от водителя до заказа). В случае ошибки возвращается HTTP 400 с соответствующим сообщением: "Координаты некорректны" при некорректных координатах заказа, "Свободных водителей нет" при отсутствии водителей на карте.

### Swagger UI
Для удобной отправки и просмотра запросов добавлена поддержка Swagger UI. В режиме разработки интерфейс доступен по адресу /swagger и позволяет отправлять запросы ко всем эндпоинтам, просматривать схемы входных и выходных данных.

### Ограничение параллельных запросов
Для ограничения числа одновременно обрабатываемых запросов разработан кастомный middleware-компонент RateLimitingMiddleware. Лимит одновременных запросов задаётся в appsettings.json в секции Settings параметром ParallelLimit и привязывается через IOptions<SettingsConfig>.

Middleware работает по принципу потокобезопасного инкремента и декремента: при поступлении запроса счётчик текущих обрабатываемых запросов атомарно увеличивается через Interlocked.Increment. Если полученное значение превышает установленный лимит, счётчик немедленно откатывается через Interlocked.Decrement и клиенту возвращается HTTP 503 Service Unavailable. Если лимит не превышен, запрос передаётся далее по конвейеру, а после завершения обработки (в блоке finally, гарантирующем выполнение даже при исключениях) счётчик уменьшается, освобождая место для следующего запроса.

Для проверки корректности работы ограничителя реализован вспомогательный эндпоинт GET /DriverOrder/slow-test с искусственной задержкой в 5 секунд. Он позволяет убедиться, что при одновременной отправке нескольких запросов лимит срабатывает и возвращает HTTP 503 при превышении (если указать в параметрах лимит на 1 запрос).

---

## Информация о задании: Часть I (для практикантов и стажеров)

Реализовать механизм подбора водителя на заказ.

Карта представляет из себя прямоугольную сетку размером N x M, которая состоит из квадратов размером 1х1, в каждом из которых может находиться только один водитель.
Координаты расположения водителя или заказа представлены в виде простых чисел X и Y, где 0 <= X < N, 0 <= Y < M. 
Каждый водитель имеет уникальный идентификатор, который указывается при добавлении или изменении его координат.

В первой части необходимо реализовать три и более разных алгоритмов, которые будут искать пять ближайших к заказу водителей.
Производительность алгоритмов нужно сравнить, используя библиотеку [Benchmark](https://github.com/dotnet/BenchmarkDotNet).  
Скриншот(-ы) результатов сравнения нужно добавить в Readme.md файл в Git.
Все разработанные алгоритмы вы должны покрыть тестами, используя NUnit.

## Ветка выполнения задания

Задание выполнялось изначально в ветке [fist-task](https://github.com/olog-hash/SmirK_Student/commit/03f604092ce17ff73ff288b0008b43fb1aaeeae6)

---

# Отчет о выполненном задании

## Архитектурное решение
Для решения задачи был выбран подход разделения способы хранения данных и алгоритма поиска.
Реализовано три типа контейнеров для хранения водителей, каждый из которых оптимизирован под определенные сценарии использования.
Для каждого контейнера разработаны специализированные алгоритмы поиска, эффективно использующие структуру данных.

Все алгоритмы поиска реализуют паттерн "стратегия", через базовый абстрактный класс BaseDriverSearchStrategy<TContainer>, что позволяет легко добавлять новые алгоритмы и переключаться между ними. (Он так же инкапсулирует логику проверки вводных данных на наличие ошибок и возвращает пустой список. Можно переопределить для каждого алгоритма опционально при желании).

## Реализованные контейнеры и алгоритмы

**1. ListGrid - Словарь водителей**

**Описание:** Простейший контейнер, хранящий водителей в виде словаря `Dictionary<int, DriverOnMap>`, где ключ - уникальный ID водителя. Доступ к водителю выполняется за О(1), однако поиск по координатам требует полного перебора всех участников списка.

**Структура данных:**
- Словарь для хранения водителей по ID.
- Поиск по координатам путем перебора водителей.

**Алгоритмы:**

- **BruteForceAlgorithm (Линейный перебор)** - перебирает всех доступных водителей из списка, вычисляет Манхэттенское расстояние до каждого и с помощью приоритетной очереди отбирает N ближайших. Оптимален для любых карт, и малого количества водителей.

**2. ClassicGrid - Двумерная сетка 1:1**

**Описание:** Контейнер представляет собой двумерную сетку, где каждая клетка соответствует одной единице координат на карте. Под капотом используется одномерный массив, обернутый в класс `FastGrid<T>` (фасад) для повышения производительности, благодаря последовательному расположению данных в памяти.

**Структура данных:**
- Одномерный массив для хранения содержимого клеток по координатам
- Словарь для быстрого доступа к водителю по ID

**Алгоритмы:**

- **BFSAlgorithm (Поиск в ширину)** - классический алгоритм обхода графа в ширину (BFS). Начиная от точки заказа, волнообразно расширяется по соседним клеткам (↑ ↓ ← →), используя очередь и массив посещенных клеток. Оптимален, для небольших карт, когда водители находятся близко к точке заказа.
- **DistanceSearchAlgorithm (Ромбовидный послойный поиск)** - обходит клетки ромбовидными слоями на основе Манхэттенского расстояния (все клетки на расстояния от точки на 1, затем 2, 3, и т.д.). Ключевая оптимизация - вместо проверки всех клеток слоя, вычисляются граничные точки (вершины ромба), по которым строятся диагонали с автоматическим обрезанием за границами карты. Оптимален для карт среднего размера с средним распределением водителей.

**3. SpatialGrid - Секторальная сетка**

**Описание:** Улучшенная версия двумерной сетки, разбивающая карту на секторы (ячейки) фиксированного размера (например 10х10 клеток). Водители группируются по секторам и хранятся в словаре `Dictionary<GridCell, List<DriverOnMap>>`. Это позволяет проверять не отдельные клетки, а целые секторы, значительно сокращая количество проверок.

**Структура данных:**
- Словарь сектором со списками водителей в каждом
- Словарь для быстрого доступа к водителю по ID
- Ленивая инициализация списков для секторов (и чистка при опустошении ячейки после удаления водителя)

**Алгоритмы:**

- **SectorGridAlgorithm (Послойный поиск по секторам)** - выполняет обход секторов квадратными слоями от точки заказа. Проверяет всех водителей текущего слоя. Ключевая оптимизация: досрочное прерывание поиска. Если минимально возможное расстояние до следующего слоя больше, чем расстояние до самого дальнего из уже найденных водителей, поиск останавливается - в следующих слоях гарантированно не будет более близких водителей. Оптимален для больших карт с неравномерным распределением водителей и при использовании подходящего размера сектора.

## Результаты бенчмарков

**Конфигурация тестирования**
- **Процессор**: Intel Core i5-12400F @ 2.50GHz (6 cores, 12 threads)
- **ОС**: Windows 10 (22H2)
- **.NET**: 6.0.36

**План бенчмарков проводился по следующим параметрам, для всех алгоритмов:**
- Размер карты: 100х100, 500х500, 1000х1000
- Плотность водителей: 1%, 10%
- Размещение водителей: Random (случайное), WorstCase (худший случай)
- Максимальное количество ближайших водителей: 10, 100
- Позиция заказа: Center (центр карты), Corner (угол карты)

Seed для генерации случайных позиций = 17. Размер ячеек (cellgrid) для SpartialGrid вычислялся по формуле `Math.Max(1, (int)(Math.Sqrt(MapSize) / 4));`

**Таблицы с результатами была оформлена в удобном порядке по параметрам:**
<details>
  
### Карта 100x100

|Алгоритм|Плотность|Размещение|MaxDrivers|Позиция|Время (ns)|Память (B)|
|---|---|---|---|---|---|---|
|**BruteForce**|0.01|Random|10|Center|4,007|1,048|
|BruteForce|0.01|Random|10|Corner|3,960|1,048|
|BruteForce|0.01|Random|100|Center|5,465|7,936|
|BruteForce|0.01|WorstCase|10|Center|3,597|1,048|
|BruteForce|0.01|WorstCase|100|Corner|5,169|7,936|
|BruteForce|0.10|Random|10|Center|40,406|1,048|
|BruteForce|0.10|Random|100|Center|88,553|7,936|
|BruteForce|0.10|WorstCase|10|Center|32,651|1,048|
|BruteForce|0.10|WorstCase|100|Corner|71,614|7,936|
|**BFS**|0.01|Random|10|Center|18,898|15,144|
|BFS|0.01|Random|10|Corner|22,314|13,072|
|BFS|0.01|Random|100|Center|147,252|25,800|
|BFS|0.01|WorstCase|10|Center|142,805|19,264|
|BFS|0.01|WorstCase|100|Corner|146,620|21,680|
|BFS|0.10|Random|10|Center|3,192|13,072|
|BFS|0.10|Random|100|Center|19,359|21,680|
|BFS|0.10|WorstCase|10|Center|52,583|19,264|
|BFS|0.10|WorstCase|100|Corner|130,973|21,680|
|**DistanceSearch**|0.01|Random|10|Center|2,616|872|
|DistanceSearch|0.01|Random|10|Corner|3,857|872|
|DistanceSearch|0.01|Random|100|Center|21,273|7,408|
|DistanceSearch|0.01|WorstCase|10|Center|18,979|872|
|DistanceSearch|0.01|WorstCase|100|Corner|24,334|7,408|
|DistanceSearch|0.10|Random|10|Center|540|1,032|
|DistanceSearch|0.10|Random|100|Center|3,065|7,408|
|DistanceSearch|0.10|WorstCase|10|Center|7,252|872|
|DistanceSearch|0.10|WorstCase|100|Corner|21,720|7,824|
|**SectorGrid**|0.01|Random|10|Center|14,949|16,160|
|SectorGrid|0.01|Random|10|Corner|30,257|71,832|
|SectorGrid|0.01|Random|100|Center|67,555|70,192|
|SectorGrid|0.01|WorstCase|10|Center|70,331|63,304|
|SectorGrid|0.01|WorstCase|100|Corner|105,747|242,568|
|SectorGrid|0.10|Random|10|Center|4,838|3,960|
|SectorGrid|0.10|Random|100|Center|28,614|23,048|
|SectorGrid|0.10|WorstCase|10|Center|63,273|46,248|
|SectorGrid|0.10|WorstCase|100|Corner|151,478|242,568|

### Карта 500x500

|Алгоритм|Плотность|Размещение|MaxDrivers|Позиция|Время (ns)|Память (B)|
|---|---|---|---|---|---|---|
|**BruteForce**|0.01|Random|10|Center|110,096|1,048|
|BruteForce|0.01|Random|10|Corner|90,979|1,048|
|BruteForce|0.01|Random|100|Center|202,662|7,936|
|BruteForce|0.01|WorstCase|10|Center|79,778|1,048|
|BruteForce|0.01|WorstCase|100|Corner|179,091|7,936|
|BruteForce|0.10|Random|10|Center|1,108,865|1,048|
|BruteForce|0.10|Random|100|Center|1,885,718|7,936|
|BruteForce|0.10|WorstCase|10|Center|791,397|1,048|
|BruteForce|0.10|WorstCase|100|Corner|1,573,458|7,936|
|**BFS**|0.01|Random|10|Center|33,362|255,230|
|BFS|0.01|Random|10|Corner|40,126|253,189|
|BFS|0.01|Random|100|Center|201,307|274,212|
|BFS|0.01|WorstCase|10|Center|3,426,454|284,410|
|BFS|0.01|WorstCase|100|Corner|3,804,142|274,514|
|BFS|0.10|Random|10|Center|26,990|253,074|
|BFS|0.10|Random|100|Center|49,727|261,684|
|BFS|0.10|WorstCase|10|Center|1,088,048|284,185|
|BFS|0.10|WorstCase|100|Corner|3,094,556|274,342|
|**DistanceSearch**|0.01|Random|10|Center|2,095|872|
|DistanceSearch|0.01|Random|10|Corner|3,712|872|
|DistanceSearch|0.01|Random|100|Center|25,249|7,408|
|DistanceSearch|0.01|WorstCase|10|Center|474,146|872|
|DistanceSearch|0.01|WorstCase|100|Corner|599,942|7,568|
|DistanceSearch|0.10|Random|10|Center|502|1,032|
|DistanceSearch|0.10|Random|100|Center|2,996|7,408|
|DistanceSearch|0.10|WorstCase|10|Center|130,638|872|
|DistanceSearch|0.10|WorstCase|100|Corner|503,277|7,600|
|**SectorGrid**|0.01|Random|10|Center|3,932|3,960|
|SectorGrid|0.01|Random|10|Corner|7,373|13,968|
|SectorGrid|0.01|Random|100|Center|43,895|31,816|
|SectorGrid|0.01|WorstCase|10|Center|332,347|244,064|
|SectorGrid|0.01|WorstCase|100|Corner|532,250|949,328|
|SectorGrid|0.10|Random|10|Center|3,189|1,600|
|SectorGrid|0.10|Random|100|Center|20,778|10,848|
|SectorGrid|0.10|WorstCase|10|Center|460,236|143,456|
|SectorGrid|0.10|WorstCase|100|Corner|1,882,291|949,328|

### Карта 1000x1000

|Алгоритм|Плотность|Размещение|MaxDrivers|Позиция|Время (ns)|Память (B)|
|---|---|---|---|---|---|---|
|**BruteForce**|0.01|Random|10|Center|444,628|1,048|
|BruteForce|0.01|Random|10|Corner|358,988|1,048|
|BruteForce|0.01|Random|100|Center|771,784|7,936|
|BruteForce|0.01|WorstCase|10|Center|313,977|1,048|
|BruteForce|0.01|WorstCase|100|Corner|656,456|7,936|
|BruteForce|0.10|Random|10|Center|4,791,151|1,048|
|BruteForce|0.10|Random|100|Center|7,314,061|7,936|
|BruteForce|0.10|WorstCase|10|Center|3,293,485|1,048|
|BruteForce|0.10|WorstCase|100|Corner|5,701,761|7,936|
|**BFS**|0.01|Random|10|Center|77,020|1,005,172|
|BFS|0.01|Random|10|Corner|83,532|1,003,121|
|BFS|0.01|Random|100|Center|274,577|1,024,068|
|BFS|0.01|WorstCase|10|Center|18,432,111|1,066,680|
|BFS|0.01|WorstCase|100|Corner|22,462,497|1,040,424|
|BFS|0.10|Random|10|Center|140,050|1,002,052|
|BFS|0.10|Random|100|Center|156,215|1,011,693|
|BFS|0.10|WorstCase|10|Center|5,137,099|1,066,796|
|BFS|0.10|WorstCase|100|Corner|18,787,403|1,040,424|
|**DistanceSearch**|0.01|Random|10|Center|1,187|872|
|DistanceSearch|0.01|Random|10|Corner|2,651|872|
|DistanceSearch|0.01|Random|100|Center|22,456|7,408|
|DistanceSearch|0.01|WorstCase|10|Center|3,006,623|872|
|DistanceSearch|0.01|WorstCase|100|Corner|5,436,030|7,568|
|DistanceSearch|0.10|Random|10|Center|414|936|
|DistanceSearch|0.10|Random|100|Center|3,021|7,600|
|DistanceSearch|0.10|WorstCase|10|Center|590,481|872|
|DistanceSearch|0.10|WorstCase|100|Corner|6,417,387|7,600|
|**SectorGrid**|0.01|Random|10|Center|1,486|1,600|
|SectorGrid|0.01|Random|10|Corner|2,941|5,104|
|SectorGrid|0.01|Random|100|Center|25,527|18,664|
|SectorGrid|0.01|WorstCase|10|Center|836,066|477,640|
|SectorGrid|0.01|WorstCase|100|Corner|1,420,428|1,892,840|
|SectorGrid|0.10|Random|10|Center|1,661|1,272|
|SectorGrid|0.10|Random|100|Center|14,488|9,096|
|SectorGrid|0.10|WorstCase|10|Center|1,555,188|269,216|
|SectorGrid|0.10|WorstCase|100|Corner|7,523,910|1,892,840|

</details>

**Скриншоты из бенчмарка из консоли программы:**

<details>
  
  ![Part_1](https://github.com/user-attachments/assets/ae98cd4e-bffe-43fd-9ace-909ba49d8724)
  
  ![Part_2](https://github.com/user-attachments/assets/6d8113d0-4faa-4d91-af2d-bc23e8b4af18)
  
  ![Part_3](https://github.com/user-attachments/assets/0929aea1-915d-4ef8-afcb-84ca72211265)
  
  ![Part_4](https://github.com/user-attachments/assets/d6658836-b930-4249-906d-0b02cf131273)
  
  ![Part_5](https://github.com/user-attachments/assets/77245d97-6d3f-41f7-bbfb-3ec5d0e57950)
  
</details>

### Анализ результатов

#### Малая карты (100х100)

При низкой плотности водителей (1%) все алгоритмы показывают достаточно приемлемую производительность. DistanceSearch демонстрирует лучшее время (2.65 μs) благодаря эффективному ромбовидному обходу. При высокой плотности (10%) DistanceSearch остается лидером (0.54 μs), так как быстро находит водителей в ближайших слоях.

BFS показывает нестабильную производительность: на низкой плотности работает медленно (18.9 μs), но на высокой плотности превосходит BruteForce (3.19 μs против 40.41 μs), так как водители находятся ближе к точке заказа.

SectorGrid на малых картах неэффективен из-за накладной работы с секторами при малом количестве данных - сначала ему требуется найти нужный сектор в словаре, а потом перебирать в нем водителей.

#### Средняя карта (500х500)

На средних картах уже четче проявляются различия между алгоритмами. DistanceSearch сохраняет лидерство при любой конфигурации: от 0.5 μs (на высокой плотности) до 474.15 μs (при худшем сценарии на низкой плотности).

BruteForce начинает значительно деградировать при росте количества водителей: при плотности 10% время достигает 1,108.87 μs, что в 2,216 раз медленнее DistanceSearch.

SectorGrid на средних картах начинает проявлять свои преимущества при высокой плотности (3.19 μs для 10% плотности), но с худших сценариях уступает DistanceSearch

BFS показывает себя хуже всех алгоритмов в этом случаи. При сложных сценариях (удаленность водителей к краям карты, большая численность требуемых водителей), алгоритм показывает от 1,088 μs до 3,804 μs.

#### Большая карта (1000х1000)

На больших картах DistanceSearch и SectorGrid демонстрируют наилучшие результаты. При случайном распределении и высокой плотности SectorGrid показывает время 1.66 μs против 0.41 μs у DistanceSearch - разница минимальна. Хоть по памяти SectorGrid явно выше - доходит до 1.8 МБ при худшем случае и большой численности искомых водителей.

BruteForce полностью непригоден для больших карт: при плотности 10% время достигает 4.79 ms, что в 11,680 раз медленнее DistanceSearch.

BFS на больших картах тоже испытывает трудности: от 18.432 ms до 22.462 мс. Отдельно можно отметить его значительное потребление памяти ~ 1 MB, из-за необходимости хранения массива посещенных клеток. Все это делает данный алгоритм неоптимальным в качестве выбора.

#### Выводы тестирования

- **DistanceSearch (ManhattanRadialSearch)** - универсальный выбор для карт умеренных размеров (не слишком больших) и плотностей. Потребление памяти имело предел ~ 8 KB и при этом сохранялась стабильная производительность. Алгоритм является оптимальным в большинстве случаев. Проседает лишь в случае если водители находятся очень далеко от точки заказа, либо же если их нужно искать слишком много.

- **SectorGrid** - лучший выбор для очень больших карт (1000х1000+) с высокой плотностью водителей. Однако требуется правильно подобрать настройки размера сектора. Преимущественно зависимость идет от количества необходимых водителей и удаленности точки заказа на карте.

- **BFS** - эффективен только на малых картах с высокой плотностью водителей вблизи точки заказа. Высокое потребление как по производительности, так и по памяти, среди всех остальных алгоритмов.

- **BruteForce** - приемлем только для малых карт с низкой плотностью (менее 100 водителей). При наличии больших данных крайне неэффективен. Однако справлялся лучше, чем алгоритм BFS.

## Покрытие тестами

Все алгоритмы и контейнеры покрыты юнит-тестами с использованием фреймворка NUnit. Благодаря использованию паттернов и абстрактных базовых классов, выстроенная система позволяет достаточно гибко создать единую базу тестов, которая автоматический применяется ко всем реализациям контейнеров и алгоритмов. Тем более это правильно, ибо задача должна выполняться как правило одинаково для всех разработанных алгоритмов.

Тестирование было разделено на три основные категории, каждая из которых проверяет свою зону функциональности.

### 1. Тестирование работы контейнеров (BaseContainerTests)
Данная категория проверяет корректность работы контейнеров для хранения водителей. Тесты проверяют основные операции работы с данными независимо от алгоритмов поиска.

**1.1 Валидация границ карты:**
- Добавление водителя с отрицательной координатой по X или Y возвращает InvalidPosition
- Добавление водителя за пределами ширины или высоты карты возвращает InvalidPosition
- Перемещение существующего водителя на отрицательные координаты возвращает InvalidPosition
- Перемещение существующего водителя за границы карты возвращает InvalidPosition

**1.2 Обработка конфликтов позиций:**
- Добавление нового водителя на позицию, занятую другим водителем, возвращает OccupiedPosition
- Перемещение водителя на позицию, занятую другим водителем, возвращает OccupiedPosition
- Перемещение водителя на его собственные координаты возвращает Updated

**1.3 Корректность операций добавления:**
- Добавление водителя на свободную валидную позицию возвращает Added
- Последовательное добавление нескольких водителей на разные позиции успешно выполняется
- Перемещение существующего водителя на новую свободную позицию возвращает Updated

**1.4 Корректность операций удаления:**
- Удаление существующего водителя возвращает Removed и уменьшает счетчик
- Удаление несуществующего водителя возвращает InvalidDriver
- Удаление водителя после неудачного добавления возвращает InvalidDriver
- Последовательное удаление нескольких водителей корректно обрабатывается

**1.5 Целостность счетчика водителей:**
- Счетчик увеличивается при добавлении водителей
- Счетчик уменьшается при удалении водителей
- Счетчик не изменяется при неудачных операциях

**1.6 Стресс-тестирование массовыми операциями:**
- Последовательное добавление 100 водителей на уникальные позиции
- Последовательное удаление всех 100 водителей
- Выполнение 100 операций перемещения водителей (10 водителей x 10 перемещений)

**1.7 Повторное использование идентификаторов:**
- ID удаленного водителя можно использовать для создания нового водителя
- Позиция удаленного водителя может быть занята новым водителем
- Новый водитель с повторно использованным ID является независимым объектом

**1.8 Освобождение позиций при перемещении:**
- При перемещении водителя его старая позиция освобождается
- При перемещении нескольких водителей все старые позиции освобождаются корректно

### 2. Тестирование работоспособности алгоритмов (BaseAlgorithmTests)
Данная категория проверяет корректность работы алгоритмов поиска при различных входных данных в конфигурациях карты.

**2.1 Обработка некорректных параметров поиска:**
- Поиск с отрицательной координатой X или Y возвращает пустой список
- Поиск с координатой X или Y за пределами карты возвращает пустой список
- Поиск с maxDrivers <= 0 возвращает пустой список

**2.2 Работа на минимальной сетке 1х1:**
- Поиск на пустой сетке 1×1 возвращает пустой список
- Поиск единственного водителя на сетке 1х1 возвращает водителя с расстоянием 0
- После удаления водителя поиск возвращает пустой список

**2.3 Работа на обычной квадратной сетке 9х9:**
- Поиск на пустой сетве 9х9 возвращает пустой список
- Поиск единственного водителя корректно вычисляет расстояние
- Размещение водителей по четырем углам и поиск из центра находит всех с одинаковым расстоянием
- После удаления водителя он не появляется в результатах поиска
- Перемещение водителя на его текущие координаты не вызывает ошибок
- Попытка переместить водителя за границу отклоняется, водитель остается на старой позиции
- Попытка переместить водителя на занятую позицию отклоняется

**2.4 Работа на узкой прямоугольной сетке 1х9:**
- Поиск на пустой сетке 1x9 возвращает пустой список
- Единственный водитель на линии находится с правильным расстоянием
- Несколько водителей на линии находятся в правильном порядке по возрастанию расстояния

**2.5 Работа на прямоуголько сетке 3х9:**
- Поиск на пустой сетке 3x9 возвращает пустой список
- Единственный водитель находится с корректным расстоянием

**2.6 Функциональные тесты в нормальных условиях:**
- При maxDrivers = 1 алгоритм возвращает одного ближайшего водителя
- При maxDrivers равном количеству водителей возвращаются все водители
- При maxDrivers больше количества водителей возвращаются все доступные
- Результаты отсортированы по возрастанию расстояния
- Расстояния вычисляются корректно для известных конфигураций

### 3. Тестирование мат-части (BaseMathematicalCorrectnessTests)
Данная категория проверяет математическую точность алгоритмов и их способность действительно находить ближайших водителей согласно метрике манхэттенского расстояния.

**3.1 Точность вычисления расстояний:**
- Водитель в точке заказа имеет расстояние 0
- Для известных конфигураций точек вычисляются ожидаемые манхэттенские расстояния
- Все вычисленные расстояния неотрицательные

**3.2 Свойство ближайших водителей:**
- Если найден водитель на расстоянии D, все водители на расстояниях 0...D-1 также найдены
- Водители на слоях расстояний находятся строго по слоям в порядке возрастания

**3.3 Математические варианты результата:**
- Результаты строго отсортированы по неубыванию расстояния
- Количество результатов не превышает maxDrivers
- Количество результатов не превышает реально доступных водителей

**3.4 Поиск из граничных позиций:**
- Поиск из левого верхнего угла находит ближайших водителей корректно
- Поиск из правого нижнего угла находит ближайших водителей корректно
- Поиск из центра карты находит симметрично расположенных водителей с одинаковым расстоянием

**3.5 Специальные настройки водителей:**
- Все водители на одинаковом расстоянии от точки поиска находятся все
- Водители по прямой линии (лестница) находятся строго в порядке возрастания
- Горизонтальная линия водителей обрабатывается с учетом симметрии
- Вертикальная линия водителей обрабатывается с учетом симметрии

**3.6 Прочие сценарии:**
- Одинокий близкий водитель находится первым при наличии плотного скопления далеких
- При широком разбросе расстояний находятся только N ближайших, остальные отсекаются
